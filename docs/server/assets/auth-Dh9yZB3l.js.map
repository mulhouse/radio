{"version":3,"file":"auth-Dh9yZB3l.js","names":["createServerFn","z","redirect","createAdminClient","createSessionClient","AppwriteException","ID","deleteCookie","getCookie","setCookie","setResponseStatus","getRequestHeader","getAppwriteSessionFn","method","handler","opts","signal","getAppwriteSessionFn.__executeServer","session","setAppwriteSessionCookiesSchema","object","id","string","secret","expires","optional","setAppwriteSessionCookiesFn","inputValidator","setAppwriteSessionCookiesFn.__executeServer","data","infer","maxAge","expireTime","Math","floor","Date","getTime","now","max","httpOnly","secure","sameSite","path","signUpInSchema","email","password","min","signUpFn","signUpFn.__executeServer","redirectUrl","account","create","userId","unique","createEmailPasswordSession","$id","expire","undefined","_error","error","code","message","status","to","signInFn","signInFn.__executeServer","signOutFn","signOutFn.__executeServer","client","deleteSession","sessionId","console","clearAuthCookies","authMiddleware","authMiddleware.__executeServer","currentUser","getCurrentUser","process","env","APPWRITE_PROJECT_ID","getCurrentUser.__executeServer","get","forgotPasswordSchema","forgotPasswordFn","forgotPasswordFn.__executeServer","origin","Error","resetUrl","createRecovery","url","success","resetPasswordSchema","confirmPassword","resetPasswordFn","resetPasswordFn.__executeServer","updateRecovery"],"sources":["../../../src/server/functions/auth.ts"],"sourcesContent":["import { createServerFn } from '@tanstack/react-start'\nimport z from 'zod'\nimport { redirect } from '@tanstack/react-router'\nimport { createAdminClient, createSessionClient } from '../lib/appwrite'\nimport { AppwriteException, ID } from 'node-appwrite'\nimport {\n  deleteCookie,\n  getCookie,\n  setCookie,\n  setResponseStatus,\n  getRequestHeader,\n} from '@tanstack/react-start/server'\n\nexport const getAppwriteSessionFn = createServerFn({ method: 'GET' }).handler(\n  async () => {\n    const session = getCookie(`appwrite-session-secret`)\n\n    if (!session) {\n      return null\n    }\n\n    return session\n  },\n)\n\nconst setAppwriteSessionCookiesSchema = z.object({\n  id: z.string(),\n  secret: z.string(),\n  expires: z.string().optional(), // ISO 8601 format string from Appwrite session.expire\n})\n\nexport const setAppwriteSessionCookiesFn = createServerFn({ method: 'POST' })\n  .inputValidator(setAppwriteSessionCookiesSchema)\n  .handler(\n    async ({\n      data,\n    }: {\n      data: z.infer<typeof setAppwriteSessionCookiesSchema>\n    }) => {\n      const { id, secret, expires } = data\n\n      // Calculate maxAge in seconds (default to 30 days if no expiration provided)\n      // Appwrite expire is always an ISO 8601 format string (e.g., \"2020-10-15T06:38:00.000+00:00\")\n      let maxAge = 30 * 24 * 60 * 60 // Default: 30 days in seconds\n      if (expires) {\n        const expireTime = Math.floor(new Date(expires).getTime() / 1000)\n        const now = Math.floor(Date.now() / 1000)\n        maxAge = Math.max(0, expireTime - now)\n      }\n\n      // Set cookies with explicit expiration\n      setCookie(`appwrite-session-secret`, secret, {\n        httpOnly: true,\n        secure: true,\n        sameSite: 'none',\n        maxAge,\n        path: '/',\n      })\n\n      setCookie(`appwrite-session-id`, id, {\n        httpOnly: true,\n        secure: true,\n        sameSite: 'none',\n        maxAge,\n        path: '/',\n      })\n    },\n  )\n\nconst signUpInSchema = z.object({\n  email: z.email('Please enter a valid email address'),\n  password: z.string().min(8, 'Password must be at least 8 characters'),\n  redirect: z.string().optional(),\n})\n\nexport const signUpFn = createServerFn({ method: 'POST' })\n  .inputValidator(signUpInSchema)\n  .handler(async ({ data }) => {\n    const { email, password, redirect: redirectUrl } = data\n    const { account } = createAdminClient()\n\n    try {\n      await account.create({ userId: ID.unique(), email, password })\n      const session = await account.createEmailPasswordSession({\n        email,\n        password,\n      })\n      await setAppwriteSessionCookiesFn({\n        data: {\n          id: session.$id,\n          secret: session.secret,\n          expires: session.expire || undefined, // ISO 8601 format string\n        },\n      })\n    } catch (_error) {\n      const error = _error as AppwriteException\n      setResponseStatus(error.code)\n      throw {\n        message: error.message,\n        status: error.code,\n      }\n    }\n\n    if (redirectUrl) {\n      throw redirect({ to: redirectUrl })\n    } else {\n      throw redirect({ to: '/' })\n    }\n  })\n\nexport const signInFn = createServerFn({ method: 'POST' })\n  .inputValidator(signUpInSchema)\n  .handler(async ({ data }) => {\n    const { email, password, redirect: redirectUrl } = data\n\n    try {\n      const { account } = createAdminClient()\n      const session = await account.createEmailPasswordSession({\n        email,\n        password,\n      })\n      await setAppwriteSessionCookiesFn({\n        data: {\n          id: session.$id,\n          secret: session.secret,\n          expires: session.expire || undefined, // ISO 8601 format string\n        },\n      })\n    } catch (_error) {\n      const error = _error as AppwriteException\n      setResponseStatus(error.code)\n      throw {\n        message: error.message,\n        status: error.code,\n      }\n    }\n\n    if (redirectUrl) {\n      throw redirect({ to: redirectUrl })\n    } else {\n      throw redirect({ to: '/' })\n    }\n  })\n\nexport const signOutFn = createServerFn({ method: 'GET' }).handler(async () => {\n  try {\n    const session = await getAppwriteSessionFn()\n\n    if (session) {\n      const client = await createSessionClient(session)\n      // Delete the session on Appwrite server\n      await client.account.deleteSession({ sessionId: 'current' })\n    }\n  } catch (error) {\n    // Even if session deletion fails, we still want to clear local cookies\n    console.error('Error deleting session:', error)\n  } finally {\n    // Always delete the cookies\n    clearAuthCookies()\n  }\n})\n\nexport const authMiddleware = createServerFn({ method: 'GET' }).handler(\n  async () => {\n    const currentUser = await getCurrentUser()\n\n    return {\n      currentUser,\n    }\n  },\n)\n\nconst clearAuthCookies = () => {\n  deleteCookie(`appwrite-session-secret`)\n  deleteCookie(`appwrite-session-id`)\n  deleteCookie(`a_session_${process.env.APPWRITE_PROJECT_ID}`)\n}\n\nexport const getCurrentUser = createServerFn({ method: 'GET' }).handler(\n  async () => {\n    const session = await getAppwriteSessionFn()\n\n    if (!session) {\n      return null\n    }\n\n    try {\n      const client = await createSessionClient(session)\n      const currentUser = await client.account.get()\n      return currentUser\n    } catch (_error) {\n      const error = _error as AppwriteException\n      if (error.code === 401) {\n        clearAuthCookies()\n      }\n      return null\n    }\n  },\n)\n\nconst forgotPasswordSchema = z.object({\n  email: z.string().email('Please enter a valid email address'),\n})\n\nexport const forgotPasswordFn = createServerFn({ method: 'POST' })\n  .inputValidator(forgotPasswordSchema)\n  .handler(async ({ data }) => {\n    const { email } = data\n    const { account } = createAdminClient()\n\n    try {\n      // Get the base URL from the origin header (includes protocol)\n      const origin = getRequestHeader('origin')\n      if (!origin) {\n        throw new Error('Missing origin header')\n      }\n      const resetUrl = `${origin}/reset-password`\n\n      await account.createRecovery({ email, url: resetUrl })\n\n      return {\n        success: true,\n        message: 'Password recovery email sent successfully',\n      }\n    } catch (_error) {\n      const error = _error as AppwriteException\n      setResponseStatus(error.code)\n      throw {\n        message: error.message,\n        status: error.code,\n      }\n    }\n  })\n\nconst resetPasswordSchema = z.object({\n  userId: z.string().min(1, 'User ID is required'),\n  secret: z.string().min(1, 'Secret is required'),\n  password: z.string().min(8, 'Password must be at least 8 characters'),\n  confirmPassword: z.string().min(8, 'Password must be at least 8 characters'),\n})\n\nexport const resetPasswordFn = createServerFn({ method: 'POST' })\n  .inputValidator(resetPasswordSchema)\n  .handler(async ({ data }) => {\n    const { userId, secret, password, confirmPassword } = data\n\n    if (password !== confirmPassword) {\n      setResponseStatus(400)\n      throw {\n        message: 'Passwords do not match',\n        status: 400,\n      }\n    }\n\n    try {\n      const { account } = createAdminClient()\n      await account.updateRecovery({\n        userId,\n        secret,\n        password,\n      })\n\n      return {\n        success: true,\n        message: 'Password reset successfully',\n      }\n    } catch (_error) {\n      const error = _error as AppwriteException\n      setResponseStatus(error.code)\n      throw {\n        message: error.message,\n        status: error.code,\n      }\n    }\n  })\n"],"mappings":"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"}