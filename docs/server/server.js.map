{"version":3,"file":"server.js","names":["getStartContext","getServerContextAfterGlobalMiddlewares","start","contextAfterGlobalMiddlewares","getStartContext","getStartOptions","startOptions","executeMiddleware","isRedirect","setCookie","deleteCookie","sanitizeBase","mergeHeaders","isRedirect","redirect"],"sources":["../../node_modules/@tanstack/react-start-server/dist/esm/StartServer.js","../../node_modules/@tanstack/react-start-server/dist/esm/defaultStreamHandler.js","../../node_modules/@tanstack/start-client-core/dist/esm/constants.js","../../node_modules/@tanstack/start-storage-context/dist/esm/async-local-storage.js","../../node_modules/@tanstack/start-client-core/dist/esm/getServerContextAfterGlobalMiddlewares.js","../../node_modules/@tanstack/start-client-core/dist/esm/getStartOptions.js","../../node_modules/@tanstack/start-client-core/dist/esm/createServerFn.js","../../node_modules/@tanstack/start-client-core/dist/esm/getDefaultSerovalPlugins.js","../../node_modules/@tanstack/start-server-core/dist/esm/request-response.js","../../node_modules/@tanstack/start-server-core/dist/esm/virtual-modules.js","../../node_modules/@tanstack/start-server-core/dist/esm/loadVirtualModule.js","../../node_modules/@tanstack/start-server-core/dist/esm/router-manifest.js","../../node_modules/@tanstack/start-server-core/dist/esm/getServerFnById.js","../../node_modules/@tanstack/start-server-core/dist/esm/server-functions-handler.js","../../node_modules/@tanstack/start-server-core/dist/esm/constants.js","../../node_modules/@tanstack/start-server-core/dist/esm/createServerRpc.js","../../node_modules/@tanstack/start-server-core/dist/esm/serializer/ServerFunctionSerializationAdapter.js","../../node_modules/@tanstack/start-server-core/dist/esm/createStartHandler.js","../../node_modules/@tanstack/react-start/dist/plugin/default-entry/server.ts"],"sourcesContent":["import { jsx } from \"react/jsx-runtime\";\nimport { RouterProvider } from \"@tanstack/react-router\";\nfunction StartServer(props) {\n  return /* @__PURE__ */ jsx(RouterProvider, { router: props.router });\n}\nexport {\n  StartServer\n};\n//# sourceMappingURL=StartServer.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { defineHandlerCallback, renderRouterToStream } from \"@tanstack/react-router/ssr/server\";\nimport { StartServer } from \"./StartServer.js\";\nconst defaultStreamHandler = defineHandlerCallback(\n  ({ request, router, responseHeaders }) => renderRouterToStream({\n    request,\n    router,\n    responseHeaders,\n    children: /* @__PURE__ */ jsx(StartServer, { router })\n  })\n);\nexport {\n  defaultStreamHandler\n};\n//# sourceMappingURL=defaultStreamHandler.js.map\n","const TSS_FORMDATA_CONTEXT = \"__TSS_CONTEXT\";\nconst TSS_SERVER_FUNCTION = Symbol.for(\"TSS_SERVER_FUNCTION\");\nconst TSS_SERVER_FUNCTION_FACTORY = Symbol.for(\n  \"TSS_SERVER_FUNCTION_FACTORY\"\n);\nconst X_TSS_SERIALIZED = \"x-tss-serialized\";\nconst X_TSS_RAW_RESPONSE = \"x-tss-raw\";\nexport {\n  TSS_FORMDATA_CONTEXT,\n  TSS_SERVER_FUNCTION,\n  TSS_SERVER_FUNCTION_FACTORY,\n  X_TSS_RAW_RESPONSE,\n  X_TSS_SERIALIZED\n};\n//# sourceMappingURL=constants.js.map\n","import { AsyncLocalStorage } from \"node:async_hooks\";\nconst startStorage = new AsyncLocalStorage();\nasync function runWithStartContext(context, fn) {\n  return startStorage.run(context, fn);\n}\nfunction getStartContext(opts) {\n  const context = startStorage.getStore();\n  if (!context && opts?.throwIfNotFound !== false) {\n    throw new Error(\n      `No Start context found in AsyncLocalStorage. Make sure you are using the function within the server runtime.`\n    );\n  }\n  return context;\n}\nexport {\n  getStartContext,\n  runWithStartContext\n};\n//# sourceMappingURL=async-local-storage.js.map\n","import { getStartContext } from \"@tanstack/start-storage-context\";\nimport { createServerOnlyFn } from \"./envOnly.js\";\nconst getServerContextAfterGlobalMiddlewares = createServerOnlyFn(() => {\n  const start = getStartContext();\n  return start.contextAfterGlobalMiddlewares;\n});\nexport {\n  getServerContextAfterGlobalMiddlewares\n};\n//# sourceMappingURL=getServerContextAfterGlobalMiddlewares.js.map\n","import { getStartContext } from \"@tanstack/start-storage-context\";\nimport { createIsomorphicFn } from \"./createIsomorphicFn.js\";\nconst getStartOptions = createIsomorphicFn().client(() => window.__TSS_START_OPTIONS__).server(() => getStartContext().startOptions);\nexport {\n  getStartOptions\n};\n//# sourceMappingURL=getStartOptions.js.map\n","import { isRedirect, isNotFound } from \"@tanstack/router-core\";\nimport { mergeHeaders } from \"@tanstack/router-core/ssr/client\";\nimport { TSS_SERVER_FUNCTION_FACTORY } from \"./constants.js\";\nimport { getServerContextAfterGlobalMiddlewares } from \"./getServerContextAfterGlobalMiddlewares.js\";\nimport { getStartOptions } from \"./getStartOptions.js\";\nconst createServerFn = (options, __opts) => {\n  const resolvedOptions = __opts || options || {};\n  if (typeof resolvedOptions.method === \"undefined\") {\n    resolvedOptions.method = \"GET\";\n  }\n  const res = {\n    options: resolvedOptions,\n    middleware: (middleware) => {\n      const newMiddleware = [...resolvedOptions.middleware || []];\n      middleware.map((m) => {\n        if (TSS_SERVER_FUNCTION_FACTORY in m) {\n          if (m.options.middleware) {\n            newMiddleware.push(...m.options.middleware);\n          }\n        } else {\n          newMiddleware.push(m);\n        }\n      });\n      const newOptions = {\n        ...resolvedOptions,\n        middleware: newMiddleware\n      };\n      const res2 = createServerFn(void 0, newOptions);\n      res2[TSS_SERVER_FUNCTION_FACTORY] = true;\n      return res2;\n    },\n    inputValidator: (inputValidator) => {\n      const newOptions = { ...resolvedOptions, inputValidator };\n      return createServerFn(void 0, newOptions);\n    },\n    handler: (...args) => {\n      const [extractedFn, serverFn] = args;\n      const newOptions = { ...resolvedOptions, extractedFn, serverFn };\n      const resolvedMiddleware = [\n        ...newOptions.middleware || [],\n        serverFnBaseToMiddleware(newOptions)\n      ];\n      return Object.assign(\n        async (opts) => {\n          return executeMiddleware(resolvedMiddleware, \"client\", {\n            ...extractedFn,\n            ...newOptions,\n            data: opts?.data,\n            headers: opts?.headers,\n            signal: opts?.signal,\n            context: {}\n          }).then((d) => {\n            if (d.error) throw d.error;\n            return d.result;\n          });\n        },\n        {\n          // This copies over the URL, function ID\n          ...extractedFn,\n          // The extracted function on the server-side calls\n          // this function\n          __executeServer: async (opts, signal) => {\n            const serverContextAfterGlobalMiddlewares = getServerContextAfterGlobalMiddlewares();\n            const ctx = {\n              ...extractedFn,\n              ...opts,\n              context: {\n                ...serverContextAfterGlobalMiddlewares,\n                ...opts.context\n              },\n              signal\n            };\n            return executeMiddleware(resolvedMiddleware, \"server\", ctx).then(\n              (d) => ({\n                // Only send the result and sendContext back to the client\n                result: d.result,\n                error: d.error,\n                context: d.sendContext\n              })\n            );\n          }\n        }\n      );\n    }\n  };\n  const fun = (options2) => {\n    return {\n      ...res,\n      options: {\n        ...res.options,\n        ...options2\n      }\n    };\n  };\n  return Object.assign(fun, res);\n};\nasync function executeMiddleware(middlewares, env, opts) {\n  const globalMiddlewares = getStartOptions()?.functionMiddleware || [];\n  const flattenedMiddlewares = flattenMiddlewares([\n    ...globalMiddlewares,\n    ...middlewares\n  ]);\n  const next = async (ctx) => {\n    const nextMiddleware = flattenedMiddlewares.shift();\n    if (!nextMiddleware) {\n      return ctx;\n    }\n    if (\"inputValidator\" in nextMiddleware.options && nextMiddleware.options.inputValidator && env === \"server\") {\n      ctx.data = await execValidator(\n        nextMiddleware.options.inputValidator,\n        ctx.data\n      );\n    }\n    const middlewareFn = env === \"client\" && \"client\" in nextMiddleware.options ? nextMiddleware.options.client : nextMiddleware.options.server;\n    if (middlewareFn) {\n      return applyMiddleware(middlewareFn, ctx, async (newCtx) => {\n        return next(newCtx).catch((error) => {\n          if (isRedirect(error) || isNotFound(error)) {\n            return {\n              ...newCtx,\n              error\n            };\n          }\n          throw error;\n        });\n      });\n    }\n    return next(ctx);\n  };\n  return next({\n    ...opts,\n    headers: opts.headers || {},\n    sendContext: opts.sendContext || {},\n    context: opts.context || {}\n  });\n}\nfunction flattenMiddlewares(middlewares) {\n  const seen = /* @__PURE__ */ new Set();\n  const flattened = [];\n  const recurse = (middleware) => {\n    middleware.forEach((m) => {\n      if (m.options.middleware) {\n        recurse(m.options.middleware);\n      }\n      if (!seen.has(m)) {\n        seen.add(m);\n        flattened.push(m);\n      }\n    });\n  };\n  recurse(middlewares);\n  return flattened;\n}\nconst applyMiddleware = async (middlewareFn, ctx, nextFn) => {\n  return middlewareFn({\n    ...ctx,\n    next: (async (userCtx = {}) => {\n      return nextFn({\n        ...ctx,\n        ...userCtx,\n        context: {\n          ...ctx.context,\n          ...userCtx.context\n        },\n        sendContext: {\n          ...ctx.sendContext,\n          ...userCtx.sendContext ?? {}\n        },\n        headers: mergeHeaders(ctx.headers, userCtx.headers),\n        result: userCtx.result !== void 0 ? userCtx.result : userCtx instanceof Response ? userCtx : ctx.result,\n        error: userCtx.error ?? ctx.error\n      });\n    })\n  });\n};\nfunction execValidator(validator, input) {\n  if (validator == null) return {};\n  if (\"~standard\" in validator) {\n    const result = validator[\"~standard\"].validate(input);\n    if (result instanceof Promise)\n      throw new Error(\"Async validation not supported\");\n    if (result.issues)\n      throw new Error(JSON.stringify(result.issues, void 0, 2));\n    return result.value;\n  }\n  if (\"parse\" in validator) {\n    return validator.parse(input);\n  }\n  if (typeof validator === \"function\") {\n    return validator(input);\n  }\n  throw new Error(\"Invalid validator type!\");\n}\nfunction serverFnBaseToMiddleware(options) {\n  return {\n    _types: void 0,\n    options: {\n      inputValidator: options.inputValidator,\n      client: async ({ next, sendContext, ...ctx }) => {\n        const payload = {\n          ...ctx,\n          // switch the sendContext over to context\n          context: sendContext\n        };\n        const res = await options.extractedFn?.(payload);\n        return next(res);\n      },\n      server: async ({ next, ...ctx }) => {\n        const result = await options.serverFn?.(ctx);\n        return next({\n          ...ctx,\n          result\n        });\n      }\n    }\n  };\n}\nexport {\n  applyMiddleware,\n  createServerFn,\n  execValidator,\n  executeMiddleware,\n  flattenMiddlewares\n};\n//# sourceMappingURL=createServerFn.js.map\n","import { defaultSerovalPlugins, makeSerovalPlugin } from \"@tanstack/router-core\";\nimport { getStartOptions } from \"./getStartOptions.js\";\nfunction getDefaultSerovalPlugins() {\n  const start = getStartOptions();\n  const adapters = start?.serializationAdapters;\n  return [\n    ...adapters?.map(makeSerovalPlugin) ?? [],\n    ...defaultSerovalPlugins\n  ];\n}\nexport {\n  getDefaultSerovalPlugins\n};\n//# sourceMappingURL=getDefaultSerovalPlugins.js.map\n","import { AsyncLocalStorage } from \"node:async_hooks\";\nimport { H3Event, toResponse, getRequestIP as getRequestIP$1, getRequestHost as getRequestHost$1, getRequestURL, getRequestProtocol as getRequestProtocol$1, sanitizeStatusCode, sanitizeStatusMessage, parseCookies, setCookie as setCookie$1, deleteCookie as deleteCookie$1, useSession as useSession$1, getSession as getSession$1, updateSession as updateSession$1, sealSession as sealSession$1, unsealSession as unsealSession$1, clearSession as clearSession$1, getValidatedQuery as getValidatedQuery$1 } from \"h3-v2\";\nconst eventStorage = new AsyncLocalStorage();\nfunction requestHandler(handler) {\n  return (request, requestOpts) => {\n    const h3Event = new H3Event(request);\n    const response = eventStorage.run(\n      { h3Event },\n      () => handler(request, requestOpts)\n    );\n    return toResponse(response, h3Event);\n  };\n}\nfunction getH3Event() {\n  const event = eventStorage.getStore();\n  if (!event) {\n    throw new Error(\n      `No StartEvent found in AsyncLocalStorage. Make sure you are using the function within the server runtime.`\n    );\n  }\n  return event.h3Event;\n}\nfunction getRequest() {\n  const event = getH3Event();\n  return event.req;\n}\nfunction getRequestHeaders() {\n  return getH3Event().req.headers;\n}\nfunction getRequestHeader(name) {\n  return getRequestHeaders().get(name) || void 0;\n}\nfunction getRequestIP(opts) {\n  return getRequestIP$1(getH3Event(), opts);\n}\nfunction getRequestHost(opts) {\n  return getRequestHost$1(getH3Event(), opts);\n}\nfunction getRequestUrl(opts) {\n  return getRequestURL(getH3Event(), opts);\n}\nfunction getRequestProtocol(opts) {\n  return getRequestProtocol$1(getH3Event(), opts);\n}\nfunction setResponseHeaders(headers) {\n  const event = getH3Event();\n  for (const [name, value] of Object.entries(headers)) {\n    event.res.headers.set(name, value);\n  }\n}\nfunction getResponseHeaders() {\n  const event = getH3Event();\n  return event.res.headers;\n}\nfunction getResponseHeader(name) {\n  const event = getH3Event();\n  return event.res.headers.get(name) || void 0;\n}\nfunction setResponseHeader(name, value) {\n  const event = getH3Event();\n  if (Array.isArray(value)) {\n    event.res.headers.delete(name);\n    for (const valueItem of value) {\n      event.res.headers.append(name, valueItem);\n    }\n  } else {\n    event.res.headers.set(name, value);\n  }\n}\nfunction removeResponseHeader(name) {\n  const event = getH3Event();\n  event.res.headers.delete(name);\n}\nfunction clearResponseHeaders(headerNames) {\n  const event = getH3Event();\n  if (headerNames && headerNames.length > 0) {\n    for (const name of headerNames) {\n      event.res.headers.delete(name);\n    }\n  } else {\n    for (const name of event.res.headers.keys()) {\n      event.res.headers.delete(name);\n    }\n  }\n}\nfunction getResponseStatus() {\n  return getH3Event().res.status || 200;\n}\nfunction setResponseStatus(code, text) {\n  const event = getH3Event();\n  if (code) {\n    event.res.status = sanitizeStatusCode(code, event.res.status);\n  }\n  if (text) {\n    event.res.statusText = sanitizeStatusMessage(text);\n  }\n}\nfunction getCookies() {\n  const event = getH3Event();\n  return parseCookies(event);\n}\nfunction getCookie(name) {\n  return getCookies()[name] || void 0;\n}\nfunction setCookie(name, value, options) {\n  const event = getH3Event();\n  setCookie$1(event, name, value, options);\n}\nfunction deleteCookie(name, options) {\n  const event = getH3Event();\n  deleteCookie$1(event, name, options);\n}\nfunction getDefaultSessionConfig(config) {\n  return {\n    name: \"start\",\n    ...config\n  };\n}\nfunction useSession(config) {\n  const event = getH3Event();\n  return useSession$1(event, getDefaultSessionConfig(config));\n}\nfunction getSession(config) {\n  const event = getH3Event();\n  return getSession$1(event, getDefaultSessionConfig(config));\n}\nfunction updateSession(config, update) {\n  const event = getH3Event();\n  return updateSession$1(event, getDefaultSessionConfig(config), update);\n}\nfunction sealSession(config) {\n  const event = getH3Event();\n  return sealSession$1(event, getDefaultSessionConfig(config));\n}\nfunction unsealSession(config, sealed) {\n  const event = getH3Event();\n  return unsealSession$1(event, getDefaultSessionConfig(config), sealed);\n}\nfunction clearSession(config) {\n  const event = getH3Event();\n  return clearSession$1(event, { name: \"start\", ...config });\n}\nfunction getResponse() {\n  const event = getH3Event();\n  return event._res;\n}\nfunction getValidatedQuery(schema) {\n  return getValidatedQuery$1(getH3Event(), schema);\n}\nexport {\n  clearResponseHeaders,\n  clearSession,\n  deleteCookie,\n  getCookie,\n  getCookies,\n  getRequest,\n  getRequestHeader,\n  getRequestHeaders,\n  getRequestHost,\n  getRequestIP,\n  getRequestProtocol,\n  getRequestUrl,\n  getResponse,\n  getResponseHeader,\n  getResponseHeaders,\n  getResponseStatus,\n  getSession,\n  getValidatedQuery,\n  removeResponseHeader,\n  requestHandler,\n  sealSession,\n  setCookie,\n  setResponseHeader,\n  setResponseHeaders,\n  setResponseStatus,\n  unsealSession,\n  updateSession,\n  useSession\n};\n//# sourceMappingURL=request-response.js.map\n","const VIRTUAL_MODULES = {\n  startManifest: \"tanstack-start-manifest:v\",\n  serverFnManifest: \"tanstack-start-server-fn-manifest:v\",\n  injectedHeadScripts: \"tanstack-start-injected-head-scripts:v\"\n};\nexport {\n  VIRTUAL_MODULES\n};\n//# sourceMappingURL=virtual-modules.js.map\n","import { VIRTUAL_MODULES } from \"./virtual-modules.js\";\nasync function loadVirtualModule(id) {\n  switch (id) {\n    case VIRTUAL_MODULES.startManifest:\n      return await import(\"tanstack-start-manifest:v\");\n    case VIRTUAL_MODULES.serverFnManifest:\n      return await import(\"tanstack-start-server-fn-manifest:v\");\n    case VIRTUAL_MODULES.injectedHeadScripts:\n      return await import(\"tanstack-start-injected-head-scripts:v\");\n    default:\n      throw new Error(`Unknown virtual module: ${id}`);\n  }\n}\nexport {\n  loadVirtualModule\n};\n//# sourceMappingURL=loadVirtualModule.js.map\n","import { rootRouteId } from \"@tanstack/router-core\";\nimport { VIRTUAL_MODULES } from \"./virtual-modules.js\";\nimport { loadVirtualModule } from \"./loadVirtualModule.js\";\nasync function getStartManifest(opts) {\n  const { tsrStartManifest } = await loadVirtualModule(\n    VIRTUAL_MODULES.startManifest\n  );\n  const startManifest = tsrStartManifest();\n  const rootRoute = startManifest.routes[rootRouteId] = startManifest.routes[rootRouteId] || {};\n  rootRoute.assets = rootRoute.assets || [];\n  let script = `import('${startManifest.clientEntry}')`;\n  if (process.env.TSS_DEV_SERVER === \"true\") {\n    const { injectedHeadScripts } = await loadVirtualModule(\n      VIRTUAL_MODULES.injectedHeadScripts\n    );\n    if (injectedHeadScripts) {\n      script = `${injectedHeadScripts + \";\"}${script}`;\n    }\n  }\n  rootRoute.assets.push({\n    tag: \"script\",\n    attrs: {\n      type: \"module\",\n      suppressHydrationWarning: true,\n      async: true\n    },\n    children: script\n  });\n  const manifest = {\n    ...startManifest,\n    routes: Object.fromEntries(\n      Object.entries(startManifest.routes).map(([k, v]) => {\n        const { preloads, assets } = v;\n        return [\n          k,\n          {\n            preloads,\n            assets\n          }\n        ];\n      })\n    )\n  };\n  return manifest;\n}\nexport {\n  getStartManifest\n};\n//# sourceMappingURL=router-manifest.js.map\n","import { loadVirtualModule } from \"./loadVirtualModule.js\";\nimport { VIRTUAL_MODULES } from \"./virtual-modules.js\";\nasync function getServerFnById(serverFnId) {\n  const { default: serverFnManifest } = await loadVirtualModule(\n    VIRTUAL_MODULES.serverFnManifest\n  );\n  const serverFnInfo = serverFnManifest[serverFnId];\n  if (!serverFnInfo) {\n    console.info(\"serverFnManifest\", serverFnManifest);\n    throw new Error(\"Server function info not found for \" + serverFnId);\n  }\n  const fnModule = await serverFnInfo.importer();\n  if (!fnModule) {\n    console.info(\"serverFnInfo\", serverFnInfo);\n    throw new Error(\"Server function module not resolved for \" + serverFnId);\n  }\n  const action = fnModule[serverFnInfo.functionName];\n  if (!action) {\n    console.info(\"serverFnInfo\", serverFnInfo);\n    console.info(\"fnModule\", fnModule);\n    throw new Error(\n      `Server function module export not resolved for serverFn ID: ${serverFnId}`\n    );\n  }\n  return action;\n}\nexport {\n  getServerFnById\n};\n//# sourceMappingURL=getServerFnById.js.map\n","import { isNotFound } from \"@tanstack/router-core\";\nimport invariant from \"tiny-invariant\";\nimport { getDefaultSerovalPlugins, TSS_FORMDATA_CONTEXT, X_TSS_RAW_RESPONSE, X_TSS_SERIALIZED } from \"@tanstack/start-client-core\";\nimport { toCrossJSONStream, toCrossJSONAsync, fromJSON } from \"seroval\";\nimport { getResponse } from \"./request-response.js\";\nimport { getServerFnById } from \"./getServerFnById.js\";\nfunction sanitizeBase(base) {\n  if (!base) {\n    throw new Error(\n      \"ðŸš¨ process.env.TSS_SERVER_FN_BASE is required in start/server-handler/index\"\n    );\n  }\n  return base.replace(/^\\/|\\/$/g, \"\");\n}\nconst handleServerAction = async ({\n  request,\n  context\n}) => {\n  const controller = new AbortController();\n  const signal = controller.signal;\n  const abort = () => controller.abort();\n  request.signal.addEventListener(\"abort\", abort);\n  const method = request.method;\n  const url = new URL(request.url, \"http://localhost:3000\");\n  const regex = new RegExp(\n    `${sanitizeBase(process.env.TSS_SERVER_FN_BASE)}/([^/?#]+)`\n  );\n  const match = url.pathname.match(regex);\n  const serverFnId = match ? match[1] : null;\n  const search = Object.fromEntries(url.searchParams.entries());\n  const isCreateServerFn = \"createServerFn\" in search;\n  if (typeof serverFnId !== \"string\") {\n    throw new Error(\"Invalid server action param for serverFnId: \" + serverFnId);\n  }\n  const action = await getServerFnById(serverFnId);\n  const formDataContentTypes = [\n    \"multipart/form-data\",\n    \"application/x-www-form-urlencoded\"\n  ];\n  const contentType = request.headers.get(\"Content-Type\");\n  const serovalPlugins = getDefaultSerovalPlugins();\n  function parsePayload(payload) {\n    const parsedPayload = fromJSON(payload, { plugins: serovalPlugins });\n    return parsedPayload;\n  }\n  const response = await (async () => {\n    try {\n      let result = await (async () => {\n        if (formDataContentTypes.some(\n          (type) => contentType && contentType.includes(type)\n        )) {\n          invariant(\n            method.toLowerCase() !== \"get\",\n            \"GET requests with FormData payloads are not supported\"\n          );\n          const formData = await request.formData();\n          const serializedContext = formData.get(TSS_FORMDATA_CONTEXT);\n          formData.delete(TSS_FORMDATA_CONTEXT);\n          const params = {\n            context,\n            data: formData\n          };\n          if (typeof serializedContext === \"string\") {\n            try {\n              const parsedContext = JSON.parse(serializedContext);\n              if (typeof parsedContext === \"object\" && parsedContext) {\n                params.context = { ...context, ...parsedContext };\n              }\n            } catch {\n            }\n          }\n          return await action(params, signal);\n        }\n        if (method.toLowerCase() === \"get\") {\n          invariant(\n            isCreateServerFn,\n            \"expected GET request to originate from createServerFn\"\n          );\n          let payload = search.payload;\n          payload = payload ? parsePayload(JSON.parse(payload)) : payload;\n          payload.context = { ...context, ...payload.context };\n          return await action(payload, signal);\n        }\n        if (method.toLowerCase() !== \"post\") {\n          throw new Error(\"expected POST method\");\n        }\n        if (!contentType || !contentType.includes(\"application/json\")) {\n          throw new Error(\"expected application/json content type\");\n        }\n        const jsonPayload = await request.json();\n        if (isCreateServerFn) {\n          const payload = parsePayload(jsonPayload);\n          payload.context = { ...payload.context, ...context };\n          return await action(payload, signal);\n        }\n        return await action(...jsonPayload);\n      })();\n      if (result.result instanceof Response) {\n        result.result.headers.set(X_TSS_RAW_RESPONSE, \"true\");\n        return result.result;\n      }\n      if (!isCreateServerFn) {\n        result = result.result;\n        if (result instanceof Response) {\n          return result;\n        }\n      }\n      if (isNotFound(result)) {\n        return isNotFoundResponse(result);\n      }\n      const response2 = getResponse();\n      let nonStreamingBody = void 0;\n      if (result !== void 0) {\n        let done = false;\n        const callbacks = {\n          onParse: (value) => {\n            nonStreamingBody = value;\n          },\n          onDone: () => {\n            done = true;\n          },\n          onError: (error) => {\n            throw error;\n          }\n        };\n        toCrossJSONStream(result, {\n          refs: /* @__PURE__ */ new Map(),\n          plugins: serovalPlugins,\n          onParse(value) {\n            callbacks.onParse(value);\n          },\n          onDone() {\n            callbacks.onDone();\n          },\n          onError: (error) => {\n            callbacks.onError(error);\n          }\n        });\n        if (done) {\n          return new Response(\n            nonStreamingBody ? JSON.stringify(nonStreamingBody) : void 0,\n            {\n              status: response2?.status,\n              statusText: response2?.statusText,\n              headers: {\n                \"Content-Type\": \"application/json\",\n                [X_TSS_SERIALIZED]: \"true\"\n              }\n            }\n          );\n        }\n        const stream = new ReadableStream({\n          start(controller2) {\n            callbacks.onParse = (value) => controller2.enqueue(JSON.stringify(value) + \"\\n\");\n            callbacks.onDone = () => {\n              try {\n                controller2.close();\n              } catch (error) {\n                controller2.error(error);\n              }\n            };\n            callbacks.onError = (error) => controller2.error(error);\n            if (nonStreamingBody !== void 0) {\n              callbacks.onParse(nonStreamingBody);\n            }\n          }\n        });\n        return new Response(stream, {\n          status: response2?.status,\n          statusText: response2?.statusText,\n          headers: {\n            \"Content-Type\": \"application/x-ndjson\",\n            [X_TSS_SERIALIZED]: \"true\"\n          }\n        });\n      }\n      return new Response(void 0, {\n        status: response2?.status,\n        statusText: response2?.statusText\n      });\n    } catch (error) {\n      if (error instanceof Response) {\n        return error;\n      }\n      if (isNotFound(error)) {\n        return isNotFoundResponse(error);\n      }\n      console.info();\n      console.info(\"Server Fn Error!\");\n      console.info();\n      console.error(error);\n      console.info();\n      const serializedError = JSON.stringify(\n        await Promise.resolve(\n          toCrossJSONAsync(error, {\n            refs: /* @__PURE__ */ new Map(),\n            plugins: serovalPlugins\n          })\n        )\n      );\n      const response2 = getResponse();\n      return new Response(serializedError, {\n        status: response2?.status ?? 500,\n        statusText: response2?.statusText,\n        headers: {\n          \"Content-Type\": \"application/json\",\n          [X_TSS_SERIALIZED]: \"true\"\n        }\n      });\n    }\n  })();\n  request.signal.removeEventListener(\"abort\", abort);\n  return response;\n};\nfunction isNotFoundResponse(error) {\n  const { headers, ...rest } = error;\n  return new Response(JSON.stringify(rest), {\n    status: 404,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...headers || {}\n    }\n  });\n}\nexport {\n  handleServerAction\n};\n//# sourceMappingURL=server-functions-handler.js.map\n","const HEADERS = {\n  TSS_SHELL: \"X-TSS_SHELL\"\n};\nexport {\n  HEADERS\n};\n//# sourceMappingURL=constants.js.map\n","import { TSS_SERVER_FUNCTION } from \"@tanstack/start-client-core\";\nimport invariant from \"tiny-invariant\";\nlet baseUrl;\nfunction sanitizeBase(base) {\n  return base.replace(/^\\/|\\/$/g, \"\");\n}\nconst createServerRpc = (functionId, splitImportFn) => {\n  if (!baseUrl) {\n    const sanitizedAppBase = sanitizeBase(process.env.TSS_APP_BASE || \"/\");\n    const sanitizedServerBase = sanitizeBase(process.env.TSS_SERVER_FN_BASE);\n    baseUrl = `${sanitizedAppBase ? `/${sanitizedAppBase}` : \"\"}/${sanitizedServerBase}/`;\n  }\n  invariant(\n    splitImportFn,\n    \"ðŸš¨splitImportFn required for the server functions server runtime, but was not provided.\"\n  );\n  const url = baseUrl + functionId;\n  return Object.assign(splitImportFn, {\n    url,\n    functionId,\n    [TSS_SERVER_FUNCTION]: true\n  });\n};\nexport {\n  createServerRpc\n};\n//# sourceMappingURL=createServerRpc.js.map\n","import { createSerializationAdapter } from \"@tanstack/router-core\";\nimport { TSS_SERVER_FUNCTION } from \"@tanstack/start-client-core\";\nimport { createServerRpc } from \"../createServerRpc.js\";\nimport { getServerFnById } from \"../getServerFnById.js\";\nconst ServerFunctionSerializationAdapter = createSerializationAdapter({\n  key: \"$TSS/serverfn\",\n  test: (v) => {\n    if (typeof v !== \"function\") return false;\n    if (!(TSS_SERVER_FUNCTION in v)) return false;\n    return !!v[TSS_SERVER_FUNCTION];\n  },\n  toSerializable: ({ functionId }) => ({ functionId }),\n  fromSerializable: ({ functionId }) => {\n    const fn = async (opts, signal) => {\n      const serverFn = await getServerFnById(functionId);\n      const result = await serverFn(opts ?? {}, signal);\n      return result.result;\n    };\n    return createServerRpc(functionId, fn);\n  }\n});\nexport {\n  ServerFunctionSerializationAdapter\n};\n//# sourceMappingURL=ServerFunctionSerializationAdapter.js.map\n","import { createMemoryHistory } from \"@tanstack/history\";\nimport { flattenMiddlewares, json, mergeHeaders } from \"@tanstack/start-client-core\";\nimport { joinPaths, trimPath, isRedirect, isResolvedRedirect, executeRewriteInput } from \"@tanstack/router-core\";\nimport { getOrigin, attachRouterServerSsrUtils } from \"@tanstack/router-core/ssr/server\";\nimport { runWithStartContext } from \"@tanstack/start-storage-context\";\nimport { requestHandler } from \"./request-response.js\";\nimport { getStartManifest } from \"./router-manifest.js\";\nimport { handleServerAction } from \"./server-functions-handler.js\";\nimport { HEADERS } from \"./constants.js\";\nimport { ServerFunctionSerializationAdapter } from \"./serializer/ServerFunctionSerializationAdapter.js\";\nfunction getStartResponseHeaders(opts) {\n  const headers = mergeHeaders(\n    {\n      \"Content-Type\": \"text/html; charset=utf-8\"\n    },\n    ...opts.router.state.matches.map((match) => {\n      return match.headers;\n    })\n  );\n  return headers;\n}\nfunction createStartHandler(cb) {\n  if (!process.env.TSS_SERVER_FN_BASE) {\n    throw new Error(\n      \"tanstack/start-server-core: TSS_SERVER_FN_BASE must be defined in your environment for createStartHandler()\"\n    );\n  }\n  const APP_BASE = process.env.TSS_APP_BASE || \"/\";\n  const serverFnBase = joinPaths([\n    APP_BASE,\n    trimPath(process.env.TSS_SERVER_FN_BASE),\n    \"/\"\n  ]);\n  let startRoutesManifest = null;\n  let startEntry = null;\n  let routerEntry = null;\n  const getEntries = async () => {\n    if (routerEntry === null) {\n      routerEntry = await import(\"#tanstack-router-entry\");\n    }\n    if (startEntry === null) {\n      startEntry = await import(\"#tanstack-start-entry\");\n    }\n    return {\n      startEntry,\n      routerEntry\n    };\n  };\n  const originalFetch = globalThis.fetch;\n  const startRequestResolver = async (request, requestOpts) => {\n    const origin = getOrigin(request);\n    globalThis.fetch = async function(input, init) {\n      function resolve(url2, requestOptions) {\n        const fetchRequest = new Request(url2, requestOptions);\n        return startRequestResolver(fetchRequest, requestOpts);\n      }\n      if (typeof input === \"string\" && input.startsWith(\"/\")) {\n        const url2 = new URL(input, origin);\n        return resolve(url2, init);\n      } else if (typeof input === \"object\" && \"url\" in input && typeof input.url === \"string\" && input.url.startsWith(\"/\")) {\n        const url2 = new URL(input.url, origin);\n        return resolve(url2, init);\n      }\n      return originalFetch(input, init);\n    };\n    const url = new URL(request.url);\n    const href = url.href.replace(url.origin, \"\");\n    let router = null;\n    const getRouter = async () => {\n      if (router) return router;\n      router = await (await getEntries()).routerEntry.getRouter();\n      const isPrerendering = process.env.TSS_PRERENDERING === \"true\";\n      let isShell = process.env.TSS_SHELL === \"true\";\n      if (isPrerendering && !isShell) {\n        isShell = request.headers.get(HEADERS.TSS_SHELL) === \"true\";\n      }\n      const history = createMemoryHistory({\n        initialEntries: [href]\n      });\n      router.update({\n        history,\n        isShell,\n        isPrerendering,\n        origin: router.options.origin ?? origin,\n        ...{\n          defaultSsr: startOptions.defaultSsr,\n          serializationAdapters: startOptions.serializationAdapters\n        }\n      });\n      return router;\n    };\n    const startOptions = await (await getEntries()).startEntry.startInstance?.getOptions() || {};\n    startOptions.serializationAdapters = startOptions.serializationAdapters || [];\n    startOptions.serializationAdapters.push(ServerFunctionSerializationAdapter);\n    const requestHandlerMiddleware = handlerToMiddleware(\n      async ({ context }) => {\n        const response2 = await runWithStartContext(\n          {\n            getRouter,\n            startOptions,\n            contextAfterGlobalMiddlewares: context\n          },\n          async () => {\n            try {\n              if (href.startsWith(serverFnBase)) {\n                return await handleServerAction({\n                  request,\n                  context: requestOpts?.context\n                });\n              }\n              const executeRouter = async ({\n                serverContext\n              }) => {\n                const requestAcceptHeader = request.headers.get(\"Accept\") || \"*/*\";\n                const splitRequestAcceptHeader = requestAcceptHeader.split(\",\");\n                const supportedMimeTypes = [\"*/*\", \"text/html\"];\n                const isRouterAcceptSupported = supportedMimeTypes.some(\n                  (mimeType) => splitRequestAcceptHeader.some(\n                    (acceptedMimeType) => acceptedMimeType.trim().startsWith(mimeType)\n                  )\n                );\n                if (!isRouterAcceptSupported) {\n                  return json(\n                    {\n                      error: \"Only HTML requests are supported here\"\n                    },\n                    {\n                      status: 500\n                    }\n                  );\n                }\n                if (startRoutesManifest === null) {\n                  startRoutesManifest = await getStartManifest({\n                    basePath: APP_BASE\n                  });\n                }\n                const router2 = await getRouter();\n                attachRouterServerSsrUtils({\n                  router: router2,\n                  manifest: startRoutesManifest\n                });\n                router2.update({ additionalContext: { serverContext } });\n                await router2.load();\n                if (router2.state.redirect) {\n                  return router2.state.redirect;\n                }\n                await router2.serverSsr.dehydrate();\n                const responseHeaders = getStartResponseHeaders({ router: router2 });\n                const response4 = await cb({\n                  request,\n                  router: router2,\n                  responseHeaders\n                });\n                return response4;\n              };\n              const response3 = await handleServerRoutes({\n                getRouter,\n                request,\n                executeRouter\n              });\n              return response3;\n            } catch (err) {\n              if (err instanceof Response) {\n                return err;\n              }\n              throw err;\n            }\n          }\n        );\n        return response2;\n      }\n    );\n    const flattenedMiddlewares = startOptions.requestMiddleware ? flattenMiddlewares(startOptions.requestMiddleware) : [];\n    const middlewares = flattenedMiddlewares.map((d) => d.options.server);\n    const ctx = await executeMiddleware(\n      [...middlewares, requestHandlerMiddleware],\n      {\n        request,\n        context: requestOpts?.context || {}\n      }\n    );\n    const response = ctx.response;\n    if (isRedirect(response)) {\n      if (isResolvedRedirect(response)) {\n        if (request.headers.get(\"x-tsr-redirect\") === \"manual\") {\n          return json(\n            {\n              ...response.options,\n              isSerializedRedirect: true\n            },\n            {\n              headers: response.headers\n            }\n          );\n        }\n        return response;\n      }\n      if (response.options.to && typeof response.options.to === \"string\" && !response.options.to.startsWith(\"/\")) {\n        throw new Error(\n          `Server side redirects must use absolute paths via the 'href' or 'to' options. The redirect() method's \"to\" property accepts an internal path only. Use the \"href\" property to provide an external URL. Received: ${JSON.stringify(response.options)}`\n        );\n      }\n      if ([\"params\", \"search\", \"hash\"].some(\n        (d) => typeof response.options[d] === \"function\"\n      )) {\n        throw new Error(\n          `Server side redirects must use static search, params, and hash values and do not support functional values. Received functional values for: ${Object.keys(\n            response.options\n          ).filter((d) => typeof response.options[d] === \"function\").map((d) => `\"${d}\"`).join(\", \")}`\n        );\n      }\n      const router2 = await getRouter();\n      const redirect = router2.resolveRedirect(response);\n      if (request.headers.get(\"x-tsr-redirect\") === \"manual\") {\n        return json(\n          {\n            ...response.options,\n            isSerializedRedirect: true\n          },\n          {\n            headers: response.headers\n          }\n        );\n      }\n      return redirect;\n    }\n    return response;\n  };\n  return requestHandler(startRequestResolver);\n}\nasync function handleServerRoutes({\n  getRouter,\n  request,\n  executeRouter\n}) {\n  const router = await getRouter();\n  let url = new URL(request.url);\n  url = executeRewriteInput(router.rewrite, url);\n  const pathname = url.pathname;\n  const { matchedRoutes, foundRoute, routeParams } = router.getMatchedRoutes(\n    pathname,\n    void 0\n  );\n  const middlewares = flattenMiddlewares(\n    matchedRoutes.flatMap((r) => r.options.server?.middleware).filter(Boolean)\n  ).map((d) => d.options.server);\n  const server = foundRoute?.options.server;\n  if (server) {\n    if (server.handlers) {\n      const handlers = typeof server.handlers === \"function\" ? server.handlers({\n        createHandlers: (d) => d\n      }) : server.handlers;\n      const requestMethod = request.method.toLowerCase();\n      let method = Object.keys(handlers).find(\n        (method2) => method2.toLowerCase() === requestMethod\n      );\n      if (!method) {\n        method = Object.keys(handlers).find(\n          (method2) => method2.toLowerCase() === \"all\"\n        ) ? \"all\" : void 0;\n      }\n      if (method) {\n        const handler = handlers[method];\n        if (handler) {\n          const mayDefer = !!foundRoute.options.component;\n          if (typeof handler === \"function\") {\n            middlewares.push(handlerToMiddleware(handler, mayDefer));\n          } else {\n            const { middleware } = handler;\n            if (middleware && middleware.length) {\n              middlewares.push(\n                ...flattenMiddlewares(middleware).map((d) => d.options.server)\n              );\n            }\n            if (handler.handler) {\n              middlewares.push(handlerToMiddleware(handler.handler, mayDefer));\n            }\n          }\n        }\n      }\n    }\n  }\n  middlewares.push(\n    handlerToMiddleware((ctx2) => executeRouter({ serverContext: ctx2.context }))\n  );\n  const ctx = await executeMiddleware(middlewares, {\n    request,\n    context: {},\n    params: routeParams,\n    pathname\n  });\n  const response = ctx.response;\n  return response;\n}\nfunction throwRouteHandlerError() {\n  if (process.env.NODE_ENV === \"development\") {\n    throw new Error(\n      `It looks like you forgot to return a response from your server route handler. If you want to defer to the app router, make sure to have a component set in this route.`\n    );\n  }\n  throw new Error(\"Internal Server Error\");\n}\nfunction throwIfMayNotDefer() {\n  if (process.env.NODE_ENV === \"development\") {\n    throw new Error(\n      `You cannot defer to the app router if there is no component defined on this route.`\n    );\n  }\n  throw new Error(\"Internal Server Error\");\n}\nfunction handlerToMiddleware(handler, mayDefer = false) {\n  if (mayDefer) {\n    return handler;\n  }\n  return async ({ next: _next, ...rest }) => {\n    const response = await handler({ ...rest, next: throwIfMayNotDefer });\n    if (!response) {\n      throwRouteHandlerError();\n    }\n    return response;\n  };\n}\nfunction executeMiddleware(middlewares, ctx) {\n  let index = -1;\n  const next = async (ctx2) => {\n    index++;\n    const middleware = middlewares[index];\n    if (!middleware) return ctx2;\n    let result;\n    try {\n      result = await middleware({\n        ...ctx2,\n        // Allow the middleware to call the next middleware in the chain\n        next: async (nextCtx) => {\n          const nextResult = await next({\n            ...ctx2,\n            ...nextCtx,\n            context: {\n              ...ctx2.context,\n              ...nextCtx?.context || {}\n            }\n          });\n          return Object.assign(ctx2, handleCtxResult(nextResult));\n        }\n        // Allow the middleware result to extend the return context\n      });\n    } catch (err) {\n      if (isSpecialResponse(err)) {\n        result = {\n          response: err\n        };\n      } else {\n        throw err;\n      }\n    }\n    return Object.assign(ctx2, handleCtxResult(result));\n  };\n  return handleCtxResult(next(ctx));\n}\nfunction handleCtxResult(result) {\n  if (isSpecialResponse(result)) {\n    return {\n      response: result\n    };\n  }\n  return result;\n}\nfunction isSpecialResponse(err) {\n  return isResponse(err) || isRedirect(err);\n}\nfunction isResponse(response) {\n  return response instanceof Response;\n}\nexport {\n  createStartHandler\n};\n//# sourceMappingURL=createStartHandler.js.map\n","import {\n  createStartHandler,\n  defaultStreamHandler,\n} from '@tanstack/react-start/server'\nimport type { Register } from '@tanstack/react-router'\nimport type { RequestHandler } from '@tanstack/react-start/server'\n\nconst fetch = createStartHandler(defaultStreamHandler)\n\nexport default {\n  // Providing `RequestHandler` from `@tanstack/react-start/server` is required so that the output types don't import it from `@tanstack/start-server-core`\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  fetch: fetch as RequestHandler<Register>,\n}\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18],"mappings":"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"}